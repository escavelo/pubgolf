// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: leaderboard.sql

package dbc

import (
	"context"

	"github.com/pubgolf/pubgolf/api/internal/lib/models"
)

const scoringCriteria = `-- name: ScoringCriteria :many
WITH st AS (
  -- Replaces the stages table in the later section with only the odd numbered stages.
  SELECT
    st.event_id, st.venue_id, st.venue_key, st.rank, st.duration_minutes, st.created_at, st.updated_at, st.deleted_at, st.rule_id, st.id,
    mod(row_number() OVER (ORDER BY st.rank ASC), 2) = 1 AS is_odd
  FROM
    stages st
  WHERE
    st.deleted_at IS NULL
    AND st.event_id = $1
),
separated AS ((
    -- Get score contributions.
    SELECT
      p.id AS player_id,
      p.name,
      coalesce(count(DISTINCT (s.id)), 0)::bigint AS num_scores,
      sum(
        CASE WHEN NOT coalesce(s.is_verified, FALSE) THEN
          0
        ELSE
          1
        END) AS num_scores_verified,
      coalesce(sum(s.value), 0)::bigint AS total_points,
      0 AS points_from_penalties,
      0 AS points_from_bonuses
    FROM
      players p
    LEFT JOIN event_players ep ON p.id = ep.player_id
    LEFT JOIN st ON st.event_id = ep.event_id
    LEFT JOIN scores s ON s.player_id = p.id
      AND s.stage_id = st.id
  WHERE
    p.deleted_at IS NULL
    AND ep.deleted_at IS NULL
    AND ep.event_id = $1
    AND ep.scoring_category = $2
    AND st.deleted_at IS NULL
    AND (st.is_odd = TRUE
      OR st.is_odd = $3::bool)
    AND s.deleted_at IS NULL
  GROUP BY
    p.id,
    p.name)
UNION (
  -- Get adjustment contributions.
  SELECT
    p.id AS player_id,
    p.name,
    0 AS num_scores,
    0 AS num_scores_verified,
    coalesce(sum(a.value), 0)::bigint AS total_points,
    sum(
      CASE WHEN a.value > 0 THEN
        a.value
      ELSE
        0
      END) AS points_from_penalties,
    sum(
      CASE WHEN a.value < 0 THEN
        a.value
      ELSE
        0
      END) AS points_from_bonuses
  FROM
    players p
    LEFT JOIN event_players ep ON p.id = ep.player_id
    LEFT JOIN st ON st.event_id = ep.event_id
      AND (st.is_odd = TRUE
        OR st.is_odd = $3::bool)
    LEFT JOIN scores s ON s.player_id = p.id
      AND s.stage_id = st.id
    LEFT JOIN adjustments a ON a.stage_id = s.stage_id
      AND a.player_id = s.player_id
  WHERE
    p.deleted_at IS NULL
    AND ep.deleted_at IS NULL
    AND ep.event_id = $1
    AND ep.scoring_category = $2
    AND st.deleted_at IS NULL
    AND s.deleted_at IS NULL
    AND a.deleted_at IS NULL
  GROUP BY
    p.id,
    p.name))
SELECT
  player_id,
  name,
  SUM(num_scores) AS num_scores,
  SUM(num_scores_verified) AS num_scores_verified,
  SUM(total_points) AS total_points,
  SUM(points_from_penalties) AS points_from_penalties,
  SUM(points_from_bonuses) AS points_from_bonuses
FROM
  separated
GROUP BY
  player_id,
  name
ORDER BY
  num_scores DESC,
  total_points ASC,
  points_from_penalties ASC,
  points_from_bonuses DESC
`

type ScoringCriteriaParams struct {
	EventID         models.EventID
	ScoringCategory models.ScoringCategory
	EveryOther      bool
}

type ScoringCriteriaRow struct {
	PlayerID            models.DatabaseULID
	Name                string
	NumScores           int64
	NumScoresVerified   int64
	TotalPoints         int64
	PointsFromPenalties int64
	PointsFromBonuses   int64
}

func (q *Queries) ScoringCriteria(ctx context.Context, arg ScoringCriteriaParams) ([]ScoringCriteriaRow, error) {
	rows, err := q.query(ctx, q.scoringCriteriaStmt, scoringCriteria, arg.EventID, arg.ScoringCategory, arg.EveryOther)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScoringCriteriaRow
	for rows.Next() {
		var i ScoringCriteriaRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Name,
			&i.NumScores,
			&i.NumScoresVerified,
			&i.TotalPoints,
			&i.PointsFromPenalties,
			&i.PointsFromBonuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
