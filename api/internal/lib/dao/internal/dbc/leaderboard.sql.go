// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: leaderboard.sql

package dbc

import (
	"context"

	"github.com/pubgolf/pubgolf/api/internal/lib/models"
)

const scoringCriteriaAllVenues = `-- name: ScoringCriteriaAllVenues :many
SELECT
  s.player_id,
  p.name,
  count(DISTINCT (s.id)) AS num_scores,
  sum(coalesce(s.value, 0)) + sum(coalesce(a.value, 0)) AS total_points,
  sum(
    CASE WHEN a.value > 0 THEN
      a.value
    ELSE
      0
    END) AS points_from_penalties,
  sum(
    CASE WHEN a.value < 0 THEN
      a.value
    ELSE
      0
    END) AS points_from_bonuses
FROM
  scores s
  JOIN players p ON s.player_id = p.id
  JOIN event_players ep ON p.id = ep.player_id
  JOIN stages st ON s.stage_id = st.id
  LEFT JOIN adjustments a ON a.stage_id = s.stage_id
    AND a.player_id = s.player_id
WHERE
  s.deleted_at IS NULL
  AND s.is_verified IS TRUE
  AND p.deleted_at IS NULL
  AND ep.deleted_at IS NULL
  AND ep.event_id = $1
  AND ep.scoring_category = $2
  AND st.deleted_at IS NULL
  AND st.event_id = $1
  AND a.deleted_at IS NULL
GROUP BY
  s.player_id,
  p.name
ORDER BY
  num_scores DESC,
  total_points ASC,
  points_from_penalties ASC,
  points_from_bonuses DESC
`

type ScoringCriteriaAllVenuesParams struct {
	EventID         models.EventID
	ScoringCategory models.ScoringCategory
}

type ScoringCriteriaAllVenuesRow struct {
	PlayerID            models.PlayerID
	Name                string
	NumScores           int64
	TotalPoints         int32
	PointsFromPenalties int64
	PointsFromBonuses   int64
}

func (q *Queries) ScoringCriteriaAllVenues(ctx context.Context, arg ScoringCriteriaAllVenuesParams) ([]ScoringCriteriaAllVenuesRow, error) {
	rows, err := q.query(ctx, q.scoringCriteriaAllVenuesStmt, scoringCriteriaAllVenues, arg.EventID, arg.ScoringCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScoringCriteriaAllVenuesRow
	for rows.Next() {
		var i ScoringCriteriaAllVenuesRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Name,
			&i.NumScores,
			&i.TotalPoints,
			&i.PointsFromPenalties,
			&i.PointsFromBonuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scoringCriteriaEveryOtherVenue = `-- name: ScoringCriteriaEveryOtherVenue :many
WITH st AS (
  SELECT
    st.event_id, st.venue_id, st.venue_key, st.rank, st.duration_minutes, st.created_at, st.updated_at, st.deleted_at, st.rule_id, st.id,
    mod(row_number() OVER (ORDER BY st.rank ASC), 2) = 1 AS is_odd
  FROM
    stages st
  WHERE
    st.deleted_at IS NULL
    AND st.event_id = $1
)
SELECT
  s.player_id,
  p.name,
  count(DISTINCT (s.id)) AS num_scores,
  sum(coalesce(s.value, 0)) + sum(coalesce(a.value, 0)) AS total_points,
  sum(
    CASE WHEN a.value > 0 THEN
      a.value
    ELSE
      0
    END) AS points_from_penalties,
  sum(
    CASE WHEN a.value < 0 THEN
      a.value
    ELSE
      0
    END) AS points_from_bonuses
FROM
  scores s
  JOIN players p ON s.player_id = p.id
  JOIN event_players ep ON p.id = ep.player_id
  JOIN st ON s.stage_id = st.id
  LEFT JOIN adjustments a ON a.stage_id = s.stage_id
    AND a.player_id = s.player_id
WHERE
  s.deleted_at IS NULL
  AND s.is_verified IS TRUE
  AND p.deleted_at IS NULL
  AND ep.deleted_at IS NULL
  AND ep.event_id = $1
  AND ep.scoring_category = $2
  AND st.deleted_at IS NULL
  AND st.event_id = $1
  AND st.is_odd
  AND a.deleted_at IS NULL
GROUP BY
  s.player_id,
  p.name
ORDER BY
  num_scores DESC,
  total_points ASC,
  points_from_penalties ASC,
  points_from_bonuses DESC
`

type ScoringCriteriaEveryOtherVenueParams struct {
	EventID         models.EventID
	ScoringCategory models.ScoringCategory
}

type ScoringCriteriaEveryOtherVenueRow struct {
	PlayerID            models.PlayerID
	Name                string
	NumScores           int64
	TotalPoints         int32
	PointsFromPenalties int64
	PointsFromBonuses   int64
}

func (q *Queries) ScoringCriteriaEveryOtherVenue(ctx context.Context, arg ScoringCriteriaEveryOtherVenueParams) ([]ScoringCriteriaEveryOtherVenueRow, error) {
	rows, err := q.query(ctx, q.scoringCriteriaEveryOtherVenueStmt, scoringCriteriaEveryOtherVenue, arg.EventID, arg.ScoringCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScoringCriteriaEveryOtherVenueRow
	for rows.Next() {
		var i ScoringCriteriaEveryOtherVenueRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Name,
			&i.NumScores,
			&i.TotalPoints,
			&i.PointsFromPenalties,
			&i.PointsFromBonuses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
