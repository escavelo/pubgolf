// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: events.sql

package dbc

import (
	"context"
	"database/sql"
	"time"

	"github.com/pubgolf/pubgolf/api/internal/lib/models"
)

const eventCacheVersionByHash = `-- name: EventCacheVersionByHash :one
SELECT
  current_schedule_cache_version
FROM
  events
WHERE
  id = $1
  AND current_schedule_cache_hash = $2
  AND deleted_at IS NULL
`

type EventCacheVersionByHashParams struct {
	ID                       models.EventID
	CurrentScheduleCacheHash []byte
}

func (q *Queries) EventCacheVersionByHash(ctx context.Context, arg EventCacheVersionByHashParams) (uint32, error) {
	row := q.queryRow(ctx, q.eventCacheVersionByHashStmt, eventCacheVersionByHash, arg.ID, arg.CurrentScheduleCacheHash)
	var current_schedule_cache_version uint32
	err := row.Scan(&current_schedule_cache_version)
	return current_schedule_cache_version, err
}

const eventIDByKey = `-- name: EventIDByKey :one
SELECT
  id
FROM
  events
WHERE
  key = $1
  AND deleted_at IS NULL
`

func (q *Queries) EventIDByKey(ctx context.Context, key string) (models.EventID, error) {
	row := q.queryRow(ctx, q.eventIDByKeyStmt, eventIDByKey, key)
	var id models.EventID
	err := row.Scan(&id)
	return id, err
}

const eventSchedule = `-- name: EventSchedule :many
SELECT
  s.venue_key,
  s.duration_minutes,
  r.description
FROM
  stages s
  LEFT JOIN rules r ON s.rule_id = r.id
WHERE
  s.event_id = $1
  AND s.deleted_at IS NULL
  AND s.deleted_at IS NULL
ORDER BY
  s.rank ASC
`

type EventScheduleRow struct {
	VenueKey        models.VenueKey
	DurationMinutes uint32
	Description     sql.NullString
}

func (q *Queries) EventSchedule(ctx context.Context, eventID models.EventID) ([]EventScheduleRow, error) {
	rows, err := q.query(ctx, q.eventScheduleStmt, eventSchedule, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventScheduleRow
	for rows.Next() {
		var i EventScheduleRow
		if err := rows.Scan(&i.VenueKey, &i.DurationMinutes, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventStartTime = `-- name: EventStartTime :one
SELECT
  starts_at
FROM
  events
WHERE
  id = $1
  AND deleted_at IS NULL
`

func (q *Queries) EventStartTime(ctx context.Context, id models.EventID) (time.Time, error) {
	row := q.queryRow(ctx, q.eventStartTimeStmt, eventStartTime, id)
	var starts_at time.Time
	err := row.Scan(&starts_at)
	return starts_at, err
}

const eventVenueKeysAreValid = `-- name: EventVenueKeysAreValid :one
SELECT
  COUNT(*) < 1
FROM
  stages s
WHERE
  s.event_id = $1
  AND s.deleted_at IS NULL
  AND s.venue_key IS NULL
`

func (q *Queries) EventVenueKeysAreValid(ctx context.Context, eventID models.EventID) (bool, error) {
	row := q.queryRow(ctx, q.eventVenueKeysAreValidStmt, eventVenueKeysAreValid, eventID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const setEventCacheKeys = `-- name: SetEventCacheKeys :one
WITH starting_cache_version AS (
  SELECT
    current_schedule_cache_version
  FROM
    events
  WHERE
    id = $1)
UPDATE
  events e
SET
  current_schedule_cache_hash = $2,
  current_schedule_cache_version = scv.current_schedule_cache_version + 1,
  updated_at = now()
FROM
  starting_cache_version scv
WHERE
  e.id = $1
RETURNING
  e.current_schedule_cache_version
`

type SetEventCacheKeysParams struct {
	ID                       models.EventID
	CurrentScheduleCacheHash []byte
}

func (q *Queries) SetEventCacheKeys(ctx context.Context, arg SetEventCacheKeysParams) (uint32, error) {
	row := q.queryRow(ctx, q.setEventCacheKeysStmt, setEventCacheKeys, arg.ID, arg.CurrentScheduleCacheHash)
	var current_schedule_cache_version uint32
	err := row.Scan(&current_schedule_cache_version)
	return current_schedule_cache_version, err
}

const setEventVenueKeys = `-- name: SetEventVenueKeys :exec
WITH starting_venue_key AS (
  SELECT
    current_venue_key
  FROM
    events
  WHERE
    id = $1
),
venue_keys AS (
  SELECT
    venue_id,
(
      SELECT
        current_venue_key
      FROM
        starting_venue_key) + row_number() OVER (ORDER BY venue_id) AS new_venue_key
    FROM
      stages
    WHERE
      event_id = $1
      AND venue_key IS NULL)
UPDATE
  stages s
SET
  venue_key = vk.new_venue_key,
  updated_at = now()
FROM
  venue_keys vk
WHERE
  s.event_id = $1
  AND vk.venue_id = s.venue_id
`

func (q *Queries) SetEventVenueKeys(ctx context.Context, eventID models.EventID) error {
	_, err := q.exec(ctx, q.setEventVenueKeysStmt, setEventVenueKeys, eventID)
	return err
}

const setNextEventVenueKey = `-- name: SetNextEventVenueKey :exec
WITH max_venue_key AS (
  SELECT
    max(venue_key)
  FROM
    stages
  WHERE
    event_id = $1
    AND venue_key IS NOT NULL)
UPDATE
  events e
SET
  current_venue_key =(
    SELECT
      max
    FROM
      max_venue_key),
  updated_at = now()
WHERE
  e.id = $1
`

func (q *Queries) SetNextEventVenueKey(ctx context.Context, id models.EventID) error {
	_, err := q.exec(ctx, q.setNextEventVenueKeyStmt, setNextEventVenueKey, id)
	return err
}
