// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: events.sql

package dbc

import (
	"context"
	"time"

	"github.com/pubgolf/pubgolf/api/internal/lib/models"
)

const eventIDByKey = `-- name: EventIDByKey :one
SELECT
  id
FROM
  events
WHERE
  key = $1
  AND deleted_at IS NULL
`

func (q *Queries) EventIDByKey(ctx context.Context, key string) (models.EventID, error) {
	row := q.queryRow(ctx, q.eventIDByKeyStmt, eventIDByKey, key)
	var id models.EventID
	err := row.Scan(&id)
	return id, err
}

const eventSchedule = `-- name: EventSchedule :many
SELECT
  ev.venue_key,
  ev.duration_minutes
FROM
  event_venues ev
WHERE
  ev.event_id = $1
  AND ev.deleted_at IS NULL
ORDER BY
  ev.rank ASC
`

type EventScheduleRow struct {
	VenueKey        models.VenueKey
	DurationMinutes uint32
}

func (q *Queries) EventSchedule(ctx context.Context, eventID models.EventID) ([]EventScheduleRow, error) {
	rows, err := q.query(ctx, q.eventScheduleStmt, eventSchedule, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventScheduleRow
	for rows.Next() {
		var i EventScheduleRow
		if err := rows.Scan(&i.VenueKey, &i.DurationMinutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventStartTime = `-- name: EventStartTime :one
SELECT
  starts_at
FROM
  events
WHERE
  id = $1
  AND deleted_at IS NULL
`

func (q *Queries) EventStartTime(ctx context.Context, id models.EventID) (time.Time, error) {
	row := q.queryRow(ctx, q.eventStartTimeStmt, eventStartTime, id)
	var starts_at time.Time
	err := row.Scan(&starts_at)
	return starts_at, err
}

const eventVenueKeysAreValid = `-- name: EventVenueKeysAreValid :one
SELECT
  COUNT(*) < 1
FROM
  event_venues ev
WHERE
  ev.event_id = $1
  AND ev.deleted_at IS NULL
  AND ev.venue_key IS NULL
`

func (q *Queries) EventVenueKeysAreValid(ctx context.Context, eventID models.EventID) (bool, error) {
	row := q.queryRow(ctx, q.eventVenueKeysAreValidStmt, eventVenueKeysAreValid, eventID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const setEventVenueKeys = `-- name: SetEventVenueKeys :exec
WITH starting_venue_key AS (
  SELECT
    current_venue_key
  FROM
    events
  WHERE
    id = $1
),
venue_keys AS (
  SELECT
    venue_id,
(
      SELECT
        current_venue_key
      FROM
        starting_venue_key) + row_number() OVER (ORDER BY venue_id) AS new_venue_key
    FROM
      event_venues
    WHERE
      event_id = $1
      AND venue_key IS NULL)
UPDATE
  event_venues ev
SET
  venue_key = vk.new_venue_key,
  updated_at = now()
FROM
  venue_keys vk
WHERE
  ev.event_id = $1
  AND vk.venue_id = ev.venue_id
`

func (q *Queries) SetEventVenueKeys(ctx context.Context, eventID models.EventID) error {
	_, err := q.exec(ctx, q.setEventVenueKeysStmt, setEventVenueKeys, eventID)
	return err
}

const setNextEventVenueKey = `-- name: SetNextEventVenueKey :exec
WITH max_venue_key AS (
  SELECT
    max(venue_key)
  FROM
    event_venues
  WHERE
    event_id = $1
    AND venue_key IS NOT NULL)
UPDATE
  events
SET
  current_venue_key =(
    SELECT
      max
    FROM
      max_venue_key),
  updated_at = now()
WHERE
  id = $1
`

func (q *Queries) SetNextEventVenueKey(ctx context.Context, id models.EventID) error {
	_, err := q.exec(ctx, q.setNextEventVenueKeyStmt, setNextEventVenueKey, id)
	return err
}
