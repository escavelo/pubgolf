// PubGolf defines the app-facing API service for the in-game apps.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file api/v1/pubgolf.proto (package api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message api.v1.ClientVersionRequest
 */
export class ClientVersionRequest extends Message<ClientVersionRequest> {
  /**
   * @generated from field: uint32 client_version = 1;
   */
  clientVersion = 0;

  constructor(data?: PartialMessage<ClientVersionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ClientVersionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientVersionRequest {
    return new ClientVersionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientVersionRequest {
    return new ClientVersionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientVersionRequest {
    return new ClientVersionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ClientVersionRequest | PlainMessage<ClientVersionRequest> | undefined, b: ClientVersionRequest | PlainMessage<ClientVersionRequest> | undefined): boolean {
    return proto3.util.equals(ClientVersionRequest, a, b);
  }
}

/**
 * @generated from message api.v1.ClientVersionResponse
 */
export class ClientVersionResponse extends Message<ClientVersionResponse> {
  /**
   * @generated from field: api.v1.ClientVersionResponse.VersionStatus version_status = 1;
   */
  versionStatus = ClientVersionResponse_VersionStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<ClientVersionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ClientVersionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version_status", kind: "enum", T: proto3.getEnumType(ClientVersionResponse_VersionStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientVersionResponse {
    return new ClientVersionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientVersionResponse {
    return new ClientVersionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientVersionResponse {
    return new ClientVersionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ClientVersionResponse | PlainMessage<ClientVersionResponse> | undefined, b: ClientVersionResponse | PlainMessage<ClientVersionResponse> | undefined): boolean {
    return proto3.util.equals(ClientVersionResponse, a, b);
  }
}

/**
 * @generated from enum api.v1.ClientVersionResponse.VersionStatus
 */
export enum ClientVersionResponse_VersionStatus {
  /**
   * @generated from enum value: VERSION_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: VERSION_STATUS_OK = 1;
   */
  OK = 1,

  /**
   * @generated from enum value: VERSION_STATUS_OUTDATED = 2;
   */
  OUTDATED = 2,

  /**
   * @generated from enum value: VERSION_STATUS_INCOMPATIBLE = 3;
   */
  INCOMPATIBLE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ClientVersionResponse_VersionStatus)
proto3.util.setEnumType(ClientVersionResponse_VersionStatus, "api.v1.ClientVersionResponse.VersionStatus", [
  { no: 0, name: "VERSION_STATUS_UNSPECIFIED" },
  { no: 1, name: "VERSION_STATUS_OK" },
  { no: 2, name: "VERSION_STATUS_OUTDATED" },
  { no: 3, name: "VERSION_STATUS_INCOMPATIBLE" },
]);

/**
 * @generated from message api.v1.GetScheduleRequest
 */
export class GetScheduleRequest extends Message<GetScheduleRequest> {
  /**
   * @generated from field: string event_key = 1;
   */
  eventKey = "";

  /**
   * @generated from field: optional uint32 cached_data_version = 2;
   */
  cachedDataVersion?: number;

  constructor(data?: PartialMessage<GetScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cached_data_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetScheduleRequest {
    return new GetScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetScheduleRequest {
    return new GetScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetScheduleRequest {
    return new GetScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetScheduleRequest | PlainMessage<GetScheduleRequest> | undefined, b: GetScheduleRequest | PlainMessage<GetScheduleRequest> | undefined): boolean {
    return proto3.util.equals(GetScheduleRequest, a, b);
  }
}

/**
 * @generated from message api.v1.GetScheduleResponse
 */
export class GetScheduleResponse extends Message<GetScheduleResponse> {
  /**
   * @generated from field: uint32 latest_data_version = 1;
   */
  latestDataVersion = 0;

  /**
   * @generated from field: optional api.v1.GetScheduleResponse.Schedule schedule = 2;
   */
  schedule?: GetScheduleResponse_Schedule;

  constructor(data?: PartialMessage<GetScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "latest_data_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "schedule", kind: "message", T: GetScheduleResponse_Schedule, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetScheduleResponse {
    return new GetScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetScheduleResponse {
    return new GetScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetScheduleResponse {
    return new GetScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetScheduleResponse | PlainMessage<GetScheduleResponse> | undefined, b: GetScheduleResponse | PlainMessage<GetScheduleResponse> | undefined): boolean {
    return proto3.util.equals(GetScheduleResponse, a, b);
  }
}

/**
 * @generated from message api.v1.GetScheduleResponse.Schedule
 */
export class GetScheduleResponse_Schedule extends Message<GetScheduleResponse_Schedule> {
  /**
   * List of past venues. Does not include the current venue.
   *
   * @generated from field: repeated uint32 visited_venue_keys = 1;
   */
  visitedVenueKeys: number[] = [];

  /**
   * Optional in the case that the event hasn't started yet.
   *
   * @generated from field: optional uint32 current_venue_key = 2;
   */
  currentVenueKey?: number;

  /**
   * Optional in the case that the next venue isn't yet visible to players, or after the second to last venue. The next venue key only becomes visible X mins before the next venue's start time.
   *
   * @generated from field: optional uint32 next_venue_key = 3;
   */
  nextVenueKey?: number;

  /**
   * @generated from field: optional google.protobuf.Timestamp next_venue_start = 4;
   */
  nextVenueStart?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp event_end = 5;
   */
  eventEnd?: Timestamp;

  constructor(data?: PartialMessage<GetScheduleResponse_Schedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetScheduleResponse.Schedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "visited_venue_keys", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 2, name: "current_venue_key", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 3, name: "next_venue_key", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 4, name: "next_venue_start", kind: "message", T: Timestamp, opt: true },
    { no: 5, name: "event_end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetScheduleResponse_Schedule {
    return new GetScheduleResponse_Schedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetScheduleResponse_Schedule {
    return new GetScheduleResponse_Schedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetScheduleResponse_Schedule {
    return new GetScheduleResponse_Schedule().fromJsonString(jsonString, options);
  }

  static equals(a: GetScheduleResponse_Schedule | PlainMessage<GetScheduleResponse_Schedule> | undefined, b: GetScheduleResponse_Schedule | PlainMessage<GetScheduleResponse_Schedule> | undefined): boolean {
    return proto3.util.equals(GetScheduleResponse_Schedule, a, b);
  }
}

/**
 * @generated from message api.v1.GetVenueRequest
 */
export class GetVenueRequest extends Message<GetVenueRequest> {
  /**
   * @generated from field: string event_key = 1;
   */
  eventKey = "";

  /**
   * @generated from field: repeated uint32 venue_keys = 2;
   */
  venueKeys: number[] = [];

  constructor(data?: PartialMessage<GetVenueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetVenueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "venue_keys", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVenueRequest {
    return new GetVenueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVenueRequest {
    return new GetVenueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVenueRequest {
    return new GetVenueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetVenueRequest | PlainMessage<GetVenueRequest> | undefined, b: GetVenueRequest | PlainMessage<GetVenueRequest> | undefined): boolean {
    return proto3.util.equals(GetVenueRequest, a, b);
  }
}

/**
 * @generated from message api.v1.GetVenueResponse
 */
export class GetVenueResponse extends Message<GetVenueResponse> {
  /**
   * Map of requested venue keys to Venue objects.
   *
   * @generated from field: map<uint32, api.v1.GetVenueResponse.VenueWrapper> venues = 1;
   */
  venues: { [key: number]: GetVenueResponse_VenueWrapper } = {};

  constructor(data?: PartialMessage<GetVenueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetVenueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "venues", kind: "map", K: 13 /* ScalarType.UINT32 */, V: {kind: "message", T: GetVenueResponse_VenueWrapper} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVenueResponse {
    return new GetVenueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVenueResponse {
    return new GetVenueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVenueResponse {
    return new GetVenueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetVenueResponse | PlainMessage<GetVenueResponse> | undefined, b: GetVenueResponse | PlainMessage<GetVenueResponse> | undefined): boolean {
    return proto3.util.equals(GetVenueResponse, a, b);
  }
}

/**
 * @generated from message api.v1.GetVenueResponse.Venue
 */
export class GetVenueResponse_Venue extends Message<GetVenueResponse_Venue> {
  /**
   * Global ID for the venue in ULID format (26 characters, base32), not to be confused with the venue key.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Address string suitable for display or using for a mapping query.
   *
   * @generated from field: string address = 3;
   */
  address = "";

  /**
   * @generated from field: string image_url = 4;
   */
  imageUrl = "";

  constructor(data?: PartialMessage<GetVenueResponse_Venue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetVenueResponse.Venue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "image_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVenueResponse_Venue {
    return new GetVenueResponse_Venue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVenueResponse_Venue {
    return new GetVenueResponse_Venue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVenueResponse_Venue {
    return new GetVenueResponse_Venue().fromJsonString(jsonString, options);
  }

  static equals(a: GetVenueResponse_Venue | PlainMessage<GetVenueResponse_Venue> | undefined, b: GetVenueResponse_Venue | PlainMessage<GetVenueResponse_Venue> | undefined): boolean {
    return proto3.util.equals(GetVenueResponse_Venue, a, b);
  }
}

/**
 * VenueWrapper allows us to return an empty wrapper in the case of an invalid or unauthorized venue ID.
 *
 * @generated from message api.v1.GetVenueResponse.VenueWrapper
 */
export class GetVenueResponse_VenueWrapper extends Message<GetVenueResponse_VenueWrapper> {
  /**
   * @generated from field: optional api.v1.GetVenueResponse.Venue venue = 1;
   */
  venue?: GetVenueResponse_Venue;

  constructor(data?: PartialMessage<GetVenueResponse_VenueWrapper>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetVenueResponse.VenueWrapper";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "venue", kind: "message", T: GetVenueResponse_Venue, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVenueResponse_VenueWrapper {
    return new GetVenueResponse_VenueWrapper().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVenueResponse_VenueWrapper {
    return new GetVenueResponse_VenueWrapper().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVenueResponse_VenueWrapper {
    return new GetVenueResponse_VenueWrapper().fromJsonString(jsonString, options);
  }

  static equals(a: GetVenueResponse_VenueWrapper | PlainMessage<GetVenueResponse_VenueWrapper> | undefined, b: GetVenueResponse_VenueWrapper | PlainMessage<GetVenueResponse_VenueWrapper> | undefined): boolean {
    return proto3.util.equals(GetVenueResponse_VenueWrapper, a, b);
  }
}

