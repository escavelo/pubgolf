package cmd

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/radovskyb/watcher"
	"github.com/spf13/cobra"
)

func init() {
	generateCmd.AddCommand(generateProtoCmd)
	generateCmd.AddCommand(generateSQLcCmd)
	generateCmd.AddCommand(generateMocksCmd)
	rootCmd.AddCommand(generateCmd)

	generateCmd.PersistentFlags().Bool("watch", false, "Watch the input directory and automatically re-run the generator.")
}

var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Run all code generation sub-tasks",
	Run: func(cmd *cobra.Command, args []string) {
		runPar(cmd, args,
			generateProtoCmd,
			generateSQLcCmd,
		)
		generateMocksCmd.Run(cmd, args)
	},
}

var generateProtoCmd = &cobra.Command{
	Use:   "proto",
	Short: "Generate protobuf and gRPC code",
	Run: func(cmd *cobra.Command, args []string) {
		watchFlag, err := cmd.Flags().GetBool("watch")
		guard(err, "check '--watch' flag")

		guard(generateProto(), "execute `buf ...` command")
		if !watchFlag {
			return
		}

		go watch(filepath.FromSlash("proto/"), "Proto codegen", func(ev watcher.Event) {
			if err := generateProto(); err != nil {
				log.Printf("Encountered error while running 'Proto codegen' task. Waiting to re-run...")
			}
		})

		<-shuttingDown
	},
}

func generateProto() error {
	buf := exec.Command("buf", "generate", "--template", filepath.FromSlash("buf.gen.dev.yaml"))
	buf.Stdout = os.Stdout
	buf.Stderr = os.Stderr
	return buf.Run()
}

var generateSQLcCmd = &cobra.Command{
	Use:   "sqlc",
	Short: "Generate SQLc queries and data holders",
	Run: func(cmd *cobra.Command, args []string) {
		watchFlag, err := cmd.Flags().GetBool("watch")
		guard(err, "check '--watch' flag")

		guard(generateSQLc(), "execute `sqlc ...` command")
		if !watchFlag {
			return
		}

		go watch(filepath.FromSlash("api/internal/db/"), "SQLc codegen", func(ev watcher.Event) {
			if err := generateSQLc(); err != nil {
				log.Printf("Encountered error while running 'SQLc codegen' task. Waiting to re-run...")
			}
		})

		<-shuttingDown
	},
}

func generateSQLc() error {
	sqlc := exec.Command("sqlc", "generate", "--file", filepath.FromSlash("api/internal/db/sqlc.yaml"))
	sqlc.Stdout = os.Stdout
	sqlc.Stderr = os.Stderr
	return sqlc.Run()
}

var generateMocksCmd = &cobra.Command{
	Use:   "mock",
	Short: "Generate DAO interface and mock",
	Run: func(cmd *cobra.Command, args []string) {
		guard(generateMock("Querier", filepath.FromSlash("api/internal/lib/dao/internal/dbc/")), "generate mock DBC")
		guard(generateInterfaceAndMock("QueryProvider", filepath.FromSlash("api/internal/lib/dao/")), "generate mock DAO")
	},
}

func generateInterfaceAndMock(ifaceName, genDir string) error {
	if err := generateInterface(ifaceName, genDir); err != nil {
		return fmt.Errorf("generate interface: %w", err)
	}

	if err := generateMock(ifaceName, genDir); err != nil {
		return fmt.Errorf("generate mock: %w", err)
	}

	return nil
}

func generateInterface(ifaceName, genDir string) error {
	args := []string{
		"--struct", "Queries",
		"--iface", ifaceName,
		"--iface-comment", "QueryProvider describes all of the queries exposed by the DAO, to allow for testing mocks.",
		"--comment", "// Code generated by ifacemaker; DO NOT EDIT.",
		"--pkg", "dao",
		"--output", filepath.Join(genDir, "gen_interface.go"),
	}

	files, err := os.ReadDir(genDir)
	if err != nil {
		return fmt.Errorf("read DAO dir: %w", err)
	}

	for _, f := range files {
		// Skip directories, symlinks, etc.
		if !f.Type().IsRegular() {
			continue
		}

		// Skip generated files.
		if strings.HasPrefix(f.Name(), "gen_") {
			continue
		}

		// Skip test files to avoid pulling in anonymous imports required for connecting to the DB.
		if strings.HasSuffix(f.Name(), "_test.go") {
			continue
		}

		args = append(args, "--file", filepath.Join(genDir, f.Name()))
	}

	iface := exec.Command("ifacemaker", args...)

	iface.Stdout = os.Stdout
	iface.Stderr = os.Stderr
	if err := iface.Run(); err != nil {
		return fmt.Errorf("run interface generator command: %w", err)
	}

	return nil
}

func generateMock(ifaceName, genDir string) error {
	mock := exec.Command("mockery",
		"--dir", genDir,
		"--name", ifaceName,
		"--filename", "gen_mock.go",
		"--inpackage",
	)

	mock.Stdout = os.Stdout
	mock.Stderr = os.Stderr
	if err := mock.Run(); err != nil {
		return fmt.Errorf("run mock generator command: %w", err)
	}

	return nil
}
